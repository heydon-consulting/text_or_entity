<?php

/**
 * @file
 * Defines the Text or Entity field type.
 */

/**
 * Implements hook_field_info().
 *
 * Field settings:
 *   - max_length: maximum length for varchar text value.
 *   - target_type: specific type of target entity.
 *   - target_bundles: specific bundle(s) of target entity.
 */
function text_or_entity_field_info() {
  return array(
    'text_or_entity' => array(
      'label' => t('Text or Entity'),
      'description' => t('This field stores varchar text and optional matching entity reference.'),
      'settings' => array(
        'max_length' => 255,
        'entity_selection' => array(
          'target_type' => 'node',
          'target_bundles' => array(),
        ),
      ),
      'instance_settings' => array(
        'text_processing' => FALSE,
      ),
      'default_widget' => 'text_or_entity_autocomplete',
      'default_formatter' => 'text_or_entity_label',

    ),
  );
}

/**
 * Implements hook_field_is_empty().
 */
function text_or_entity_field_is_empty($item, $field) {
  $empty_value = !isset($item['value']) || $item['value'] == '';
  $empty_target_id = !isset($item['target_id']) || $item['target_id'] == NULL;

  return $empty_value && $empty_target_id;
}

/**
 * Implements hook_field_validate().
 */
function text_or_entity_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  $target_type = $field['settings']['entity_selection']['target_type'];

  // Validate all text_or_entity items.
  foreach ($items as $delta => $item) {
    if (text_or_entity_field_is_empty($item, $field)) {
      // Nothing to validate, move along.
      continue;
    }
    $empty_value = !isset($item['value']) || $item['value'] == '';
    $empty_target_id = !isset($item['target_id']) || $item['target_id'] == NULL;
    if ($empty_target_id) {
      // No entity reference, validate text value as matching nothing.
      $target_matches = text_or_entity_query_entity_label($field, $instance, $item['value'], TRUE);
      if (!count($target_matches)) {
        // No matching entity for text value, move along.
        continue;
      }
      // Missing entity reference for matching text value.
      $missing_id = $target_matches[0][$item['value']]['target_id'];
      $errors[$field['field_name']][$langcode][$delta][] = array(
        'error' => 'text_or_entity_missing_target_id',
        'message' => t('Missing @type reference (@id) for matching text value "@value".',
          array(
            '@type' => $target_type,
            '@id' => $missing_id,
            '@value' => $item['value'],
          )
        ),
      );
    }
    else {
      // Validate entity reference target type.
      $target_entity = entity_load($target_type, array($item['target_id']));
      $target_entity = $target_entity[array_keys($target_entity)[0]];
      if (empty($target_entity)) {
        // Invalid entity reference for target type, move along with error.
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'text_or_entity_invalid_target_type',
          'message' => t('Invalid @type reference (@id) for target type.',
            array('@type' => $target_type, '@id' => $item['target_id'])),
        );
        continue;
      }
      // Validate entity reference target bundle(s).
      $target_bundles = $field['settings']['entity_selection']['target_bundles'];
      if (!empty($target_bundles)) {
        list(, , $entity_bundle) = entity_extract_ids($entity_type, $target_entity);
        if (!in_array($entity_bundle, $target_bundles)) {
          // Invalid entity reference for target bundle, move along with error.
          $errors[$field['field_name']][$langcode][$delta][] = array(
            'error' => 'text_or_entity_invalid_target_bundle',
            'message' => t('Invalid @type reference (@id) bundle "@bundle".',
              array(
                '@type' => $target_type,
                '@id' => $item['target_id'],
                '@bundle' => $entity_bundle,
              )
            ),
          );
        }
      }
      // Validate text value as matching label of referenced entity.
      $entity_label = entity_label($target_type, $target_entity);
      if ($empty_value) {
        // Missing text value, move along with error.
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'text_or_entity_missing_value',
          'message' => t('Missing text value "@label" for @type reference (@id).',
            array(
              '@label' => $entity_label,
              '@type' => $target_type,
              '@id' => $item['target_id'],
            )
          ),
        );
        continue;
      }
      if (strcmp($entity_label, $item['value'])) {
        // Referenced entity label does not match text value.
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'text_or_entity_invalid_value',
          'message' => t('Referenced @type "@label" (@id) does not match text value "@value".',
            array(
              '@type' => $target_type,
              '@label' => $entity_label,
              '@id' => $item['target_id'],
              '@value' => $item['value'],
            )
          ),
        );
      }
    }
  }
}

/**
 * Implements hook_field_settings_form().
 */
function text_or_entity_field_settings_form($field, $instance, $has_data) {
  $form = array(
    '#type' => 'container',
    '#prefix' => '<div id="text-or-entity-field-settings">',
    '#suffix' => '</div>',
    '#process' => array('_text_or_entity_field_settings_process'),
    '#element_validate' => array('_text_or_entity_field_settings_validate'),
    '#field' => $field,
    '#instance' => $instance,
    '#has_data' => $has_data,
  );

  return $form;
}

/**
 * Process callback to build the Text or Entity field settings form.
 */
function _text_or_entity_field_settings_process($form, $form_state) {
  $field = isset($form_state['text_or_entity']['field']) ? $form_state['text_or_entity']['field'] : $form['#field'];
  $has_data = $form['#has_data'];

  // Text value maximum length.
  $form['max_length'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum length'),
    '#default_value' => $field['settings']['max_length'],
    '#required' => TRUE,
    '#description' => t('The maximum length of the text value in characters.'),
    '#element_validate' => array('element_validate_integer_positive'),
    '#disabled' => $has_data,
  );

  // Dynamic selection of target entity type and bundle(s).
  $form['entity_selection'] = array(
    '#type' => 'fieldset',
    '#title' => t('Entity selection'),
  );
  $target_entity_type = $field['settings']['entity_selection']['target_type'];
  $form['entity_selection']['target_type'] = array(
    '#type' => 'select',
    '#title' => t('Target type'),
    '#options' => _text_or_entity_get_entity_type_options(),
    '#default_value' => $target_entity_type,
    '#description' => t('The entity type that can be referenced through this field.'),
    '#disabled' => $has_data,
    '#size' => 1,
    '#ajax' => array(
      'callback' => '_text_or_entity_field_settings_ajax_callback',
      'wrapper' => 'text-or-entity-field-settings',
    ),
  );
  $entity_info = entity_get_info($target_entity_type);
  if (!empty($entity_info['entity keys']['bundle'])) {
    // Bundles options for that entity type.
    $form['entity_selection']['target_bundles'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Target bundles'),
      '#options' => _text_or_entity_get_bundles_options($target_entity_type),
      '#default_value' => $field['settings']['entity_selection']['target_bundles'],
      '#description' => t('The bundles of the entity type that can be referenced. Optional, leave empty for all bundles.'),
      '#disabled' => $has_data,
    );
  }
  else {
    // Entity doesn't have bundles.
    $form['entity_selection']['target_bundles'] = array(
      '#type' => 'hidden',
      '#value' => array(),
    );
  }

  return $form;
}

/**
 * AJAX callback to rebuild the target_bundles settings.
 */
function _text_or_entity_field_settings_ajax_callback($form, $form_state) {
  return $form['field']['settings'];
}

/**
 * Validate field settings from the form state values.
 */
function _text_or_entity_field_settings_validate($form, &$form_state) {
  // Store the new field settings in the form state.
  $field = $form['#field'];
  if (isset($form_state['values']['field'])) {
    $field['settings'] = $form_state['values']['field']['settings'];
  }
  $form_state['text_or_entity']['field'] = $field;
}

/**
 * Helper function to get available entity types options.
 *
 * @return array
 *   The available entity types options.
 */
function _text_or_entity_get_entity_type_options() {
  $entity_type_options = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    $entity_type_options[$entity_type] = $entity_info['label'];
  }

  return $entity_type_options;
}

/**
 * Helper function to get bundles options from entity type.
 *
 * @param string $entity_type
 *   Entity type for which to retrieve bundles options.
 *
 * @return array
 *   The bundles options for that entity type.
 */
function _text_or_entity_get_bundles_options($entity_type) {
  $bundles_options = array();

  if (empty($entity_type)) {
    return array();
  }
  if ($bundles_info = field_info_bundles($entity_type)) {
    foreach ($bundles_info as $bundle_name => $bundle) {
      $bundles_options[$bundle_name] = $bundle['label'];
    }
  }

  return $bundles_options;
}

/**
 * Implements hook_field_instance_settings_form().
 */
function text_or_entity_field_instance_settings_form($field, $instance) {
  $form = array();

  $form['text_processing'] = array(
    '#type' => 'hidden',
    '#value' => FALSE,
  );

  return $form;
}

/**
 * Implements hook_field_widget_info().
 */
function text_or_entity_field_widget_info() {
  return array(
    'text_or_entity_autocomplete' => array(
      'label' => t('Autocomplete'),
      'description' => t('An autocomplete text field.'),
      'field types' => array('text_or_entity'),
      'settings' => array(
        'size' => 60,
        'match_operator' => 'STARTS_WITH',
        'limit' => 10,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function text_or_entity_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];
  $form = array();

  // Only process text_or_entity widget.
  if ($widget['type'] == 'text_or_entity_autocomplete') {
    // Textfield size.
    $form['size'] = array(
      '#type' => 'textfield',
      '#title' => t('Size of textfield'),
      '#default_value' => $settings['size'],
      '#required' => TRUE,
      '#element_validate' => array('element_validate_integer_positive'),
    );
    // Autocomplete match operator (STARTS_WITH or CONTAINS).
    $form['match_operator'] = array(
      '#type' => 'select',
      '#title' => t('Autocomplete match operator'),
      '#default_value' => $settings['match_operator'],
      '#options' => array(
        'STARTS_WITH' => t('Starts with'),
        'CONTAINS' => t('Contains'),
      ),
      '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of records.'),
    );
    // Autocomplete suggestions limit (<100).
    $form['limit'] = array(
      '#type' => 'textfield',
      '#title' => t('Autocomplete limit'),
      '#description' => t('Limit the size of the autocomplete suggestions list (<100).'),
      '#default_value' => $settings['limit'],
      '#size' => 3,
      '#maxlength' => 2,
      '#element_validate' => array('element_validate_integer_positive'),
      '#required' => TRUE,
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function text_or_entity_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  if ($instance['widget']['type'] == 'text_or_entity_autocomplete') {
    // Reuse text_textfield widget for value element.
    $instance['widget']['type'] = 'text_textfield';
    $element = text_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
    // Add autocomplete path and validation to value field.
    $autocomplete_path = 'text_or_entity/autocomplete/' . $element['#field_name'] . '/' . $element['#entity_type'] . '/' . $element['#bundle'];
    $element['value'] += array(
      '#autocomplete_path' => $autocomplete_path,
      '#element_validate' => array('_text_or_entity_autocomplete_validate'),
      '#field' => $field,
      '#instance' => $instance,
      '#langcode' => $langcode,
      '#delta' => $delta,
    );
    // Store target_id and entity_type in hidden elements.
    $target_id = isset($items[$delta]) && !empty($items[$delta]['target_id']) ? $items[$delta]['target_id'] : NULL;
    $element['target_id'] = array(
      '#type' => 'hidden',
      '#default_value' => $target_id,
    );
    $element['source_type'] = array(
      '#type' => 'hidden',
      '#value' => $element['#entity_type'],
    );
  }

  return $element;
}

/**
 * Implements hook_menu().
 *
 * We only need this for text_or_entity_autocomplete widget.
 */
function text_or_entity_menu() {
  $items = array();

  $items['text_or_entity/autocomplete/%/%/%'] = array(
    'title' => 'Text or Entity Autocomplete',
    'page callback' => 'text_or_entity_autocomplete_callback',
    'page arguments' => array(2, 3, 4),
    'access callback' => 'text_or_entity_autocomplete_access_callback',
    'access arguments' => array(2, 3, 4),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Menu Access callback for the Text or Entity autocomplete widget.
 *
 * @param string $field_name
 *   The name of the text_or_entity field.
 * @param string $entity_type
 *   The entity type.
 * @param string $bundle_name
 *   The bundle name.
 *
 * @return bool
 *   True if user can access this menu item.
 */
function text_or_entity_autocomplete_access_callback($field_name, $entity_type, $bundle_name) {
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  if (!$field || !$instance || $field['type'] != 'text_or_entity' || !field_access('edit', $field, $entity_type)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Menu callback: autocomplete previous text values or the label of an entity.
 *
 * @param string $field_name
 *   The name of the entity-reference field.
 * @param string $entity_type
 *   The entity type.
 * @param string $bundle_name
 *   The bundle name.
 * @param string $string
 *   The label of the entity to query by.
 */
function text_or_entity_autocomplete_callback($field_name, $entity_type, $bundle_name, $string = '') {
  // If the request has a '/' in the search text, then the menu system will
  // have split it into multiple arguments and $string will only be a partial.
  // We want to make sure we recover the intended $string.
  $args = func_get_args();
  // Shift off the $field_name, $entity_type and $bundle_name args.
  array_shift($args);
  array_shift($args);
  array_shift($args);
  $string = implode('/', $args);

  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  text_or_entity_autocomplete_matches_json_output($field, $instance, $entity_type, $string);
}

/**
 * Output JSON based on given field, instance and string.
 *
 * @param array $field
 *   The field array definition.
 * @param array $instance
 *   The instance array definition.
 * @param string $entity_type
 *   The entity type.
 * @param string $string
 *   The label of the entity to query by.
 */
function text_or_entity_autocomplete_matches_json_output(array $field, array $instance, $entity_type, $string = '') {
  // Get autocomplete suggestions from previous text values.
  $matches = text_or_entity_query_field_data($field, $instance, $string, FALSE);

  // Merge autocomplete suggestions from matching entities.
  $matches = array_merge($matches, text_or_entity_query_entity_label($field, $instance, $string, FALSE));

  // Process matches and sanitize output.
  $limit = $instance['widget']['settings']['limit'];
  $suggestions = array();
  foreach ($matches as $key => $match) {
    // Add a class wrapper for a few required CSS overrides.
    $suggestions[$key] = '<div class="reference-autocomplete">' . check_plain($match['value']) . '</div>';
    if (!--$limit) {
      continue;
    }
  }
  asort($suggestions, SORT_LOCALE_STRING);

  drupal_json_output($suggestions);
}

/**
 * Validation callback for widget form.
 */
function _text_or_entity_autocomplete_validate($element, &$form_state, $form) {
  if (!isset($form_state['values'][$element['#field_name']])) {
    return;
  }
  // Determine target_id from text value.
  $value = $form_state['values'][$element['#field_name']][$element['#langcode']][$element['#delta']]['value'];
  $matches = text_or_entity_query_entity_label($element['#field'], $element['#instance'], $value, TRUE);
  $target_id = count($matches) ? $matches[$value]['target_id'] : NULL;

  // Set target_id in the submitted form values.
  $parents = $element['#array_parents'];
  array_pop($parents);
  $parent_element = drupal_array_get_nested_value($form, $parents);
  form_set_value($parent_element['target_id'], $target_id, $form_state);
}

/**
 * Implements hook_field_formatter_info().
 */
function text_or_entity_field_formatter_info() {
  return array(
    'text_or_entity_label' => array(
      'label' => t('Text or Entity label'),
      'field types' => array('text_or_entity'),
      'settings' => array('link' => TRUE),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function text_or_entity_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $element = array();
  if ($display['type'] == 'text_or_entity_label') {
    $element['link'] = array(
      '#title' => t('Link label to the referenced entity'),
      '#type' => 'checkbox',
      '#default_value' => $settings['link'],
    );
  }
  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function text_or_entity_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = array();

  if ($display['type'] == 'text_or_entity_label') {
    $summary[] = $settings['link'] ? t('Link to the referenced entity') : t('No link');
  }

  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function text_or_entity_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $elements = array();

  if ($display['type'] == 'text_or_entity_label') {
    foreach ($items as $delta => $item) {
      if (isset($item['target_id']) && $item['target_id'] !== NULL && $display['settings']['link']) {
        // Display as a link to the target entity.
        $path = $field['settings']['entity_selection']['target_type'] . '/' . $item['target_id'];
        $elements[$delta] = array('#markup' => l($item['value'], $path));
      }
      else {
        // Display as text value.
        $elements[$delta] = array('#markup' => $item['value']);
      }
    }
  }

  return $elements;
}

/**
 * Helper function to query existing field data.
 *
 * @param array $field
 *   Text or Entity field for which this query should be made.
 * @param array $instance
 *   Text or Entity field instance for which this query should be made.
 * @param string $string
 *   String or partial string to search for.
 * @param bool $exact
 *   Use exact match instead of STARTS_WITH / CONTAINS.
 *
 * @return array
 *   Matching text values found in the specified field's data, for example:
 *   array('Text value' => array(
 *     'value' => 'Text value',
 *     'target_id' => NULL,
 *   ))
 */
function text_or_entity_query_field_data(array $field, array $instance, $string, $exact) {
  // Only process non-empty string and text_or_entity fields.
  if ($string == '' || $field['type'] != 'text_or_entity') {
    return array();
  }
  // Autocomplete widget settings.
  $widget = $instance['widget'];
  $match_operator = $widget['settings']['match_operator'];
  $limit = $widget['settings']['limit'];

  $matches = array();

  // Build query to search for existing field data.
  $field_name = $field['field_name'];
  $query = db_select('field_data_' . $field_name)
    ->fields('field_data_' . $field_name, array($field_name . '_value'));
  if ($exact) {
    // Query for exact value of $string.
    $query->condition($field_name . '_value', $string, '=');
  }
  else {
    // Query for value containing or starting with $string.
    $needle = db_like($string) . '%';
    if ($match_operator == 'CONTAINS') {
      $needle = '%' . $needle;
    }
    $query->condition($field_name . '_value', $needle, 'LIKE');
  }
  $query->groupBy($field_name . '_value')
    ->orderBy($field_name . '_value')
    ->range(0, $limit);
  $result = $query->execute();
  // Process query result into matches array.
  foreach ($result as $value) {
    $value = $value->{$field_name . '_value'};
    $matches[$value] = array(
      'value' => $value,
      'target_id' => NULL,
    );
  }

  return $matches;
}

/**
 * Helper function to query entities by their label value.
 *
 * @param array $field
 *   Text or Entity field for which this query should be made.
 * @param array $instance
 *   Text or Entity field instance for which this query should be made.
 * @param string $string
 *   String or partial string to search for.
 * @param bool $exact
 *   Use exact match instead of STARTS_WITH / CONTAINS.
 *
 * @return array
 *   Matching text values found in the specified field's data, for example:
 *   array('Entity label' => array(
 *     'value' => 'Entity label',
 *     'target_id' => 10,
 *   ))
 */
function text_or_entity_query_entity_label(array $field, array $instance, $string, $exact) {
  // Only process non-empty string and text_or_entity fields.
  if ($string == '' || $field['type'] != 'text_or_entity') {
    return array();
  }
  // Autocomplete widget settings.
  $widget = $instance['widget'];
  $match_operator = $widget['settings']['match_operator'];
  $limit = $widget['settings']['limit'];
  // Target entity type and bundles for that field.
  $entity_type = $field['settings']['entity_selection']['target_type'];
  $entity_bundles = $field['settings']['entity_selection']['target_bundles'];

  $matches = array();

  if ($entity_type == 'user' && module_exists('realname')) {
    // Query users based on realname.
    $query = db_select('realname')
      ->fields('realname', array('uid', 'realname'));
    if ($exact) {
      // Query for exact value of $string.
      $query->condition('realname', $string, '=');
    }
    else {
      // Query for value containing or starting with $string.
      $needle = db_like($string) . '%';
      if ($match_operator == 'CONTAINS') {
        $needle = '%' . $needle;
      }
      $query->condition('realname', $needle, 'LIKE');
    }
    $query->groupBy('uid')
      ->orderBy('realname')
      ->range(0, $limit);
    $result = $query->execute();
    // Process query result into matches array.
    foreach ($result as $value) {
      $matches[$value->realname] = array(
        'value' => $value->realname,
        'target_id' => $value->uid,
      );
    }
  }
  else {
    // Query the database to see which entities match.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', $entity_type);
    if (!empty($entity_bundles)) {
      $query->entityCondition('bundle', $entity_bundles, "IN");
    }
    $label_column = _text_or_entity_resolve_entity_label_column($entity_type);
    if ($exact) {
      $query->propertyCondition($label_column, $string, '=');
    }
    else {
      // Query for value containing or starting with $string.
      $needle = db_like($string) . '%';
      if ($match_operator == 'CONTAINS') {
        $needle = '%' . $needle;
      }
      $query->propertyCondition($label_column, $needle, 'LIKE');
    }
    $query->range(0, $limit);
    $matching_entities = $query->execute();
    // Process query result into matches.
    if (!empty($matching_entities[$entity_type])) {
      $matching_entities = entity_load($entity_type, array_keys($matching_entities[$entity_type]));
      foreach ($matching_entities as $entity) {
        if (entity_access('view', $entity_type, $entity) === FALSE) {
          continue;
        }
        list($entity_id,,) = entity_extract_ids($entity_type, $entity);
        $entity_label = entity_label($entity_type, $entity);
        $matches[$entity_label] = array(
          'value' => $entity_label,
          'target_id' => $entity_id,
        );
      }
    }
  }

  return $matches;
}

/**
 * Returns the name of the column to use as the entity label for a given entity.
 *
 * @param string $entity_type
 *   The entity type for which the column to use as label needs to be resolved.
 *
 * @return bool|string
 *   The name of the column to use as the entity label for the passed entity, or
 *   FALSE if no column can be used for that.
 */
function _text_or_entity_resolve_entity_label_column($entity_type) {
  $entity_info = entity_get_info($entity_type);
  $label_column = FALSE;

  // Check if the entity has a label column defined.
  if (isset($entity_info['entity keys']['label'])) {
    $label_column = $entity_info['entity keys']['label'];
  }
  else {
    switch ($entity_type) {
      case 'user':
        $label_column = 'name';
        break;
    }
  }
  // Still no label available, fall back to entity id column.
  if (!$label_column) {
    $label_column = $entity_info['entity keys']['id'];
    return $label_column;
  }

  return $label_column;
}

/**
 * Helper function to get all text_or_entity fields affected by entity change.
 *
 * @param string $entity_type
 *   Target entity type to look for in text_or_entity fields.
 *   Leave empty to get all text_or_entity fields.
 * @param string $entity_bundle
 *   Target entity bundle to look for in text_or_entity fields.
 *   Leave empty for all entity bundles of $entity_type.
 * @param bool $reset_cache
 *   If TRUE, rebuild static cache for $field_map.
 *
 * @return array
 *   Array of potentially affected field names.
 */
function _text_or_entity_field_map($entity_type = '', $entity_bundle = '', $reset_cache = FALSE) {
  static $field_map;

  if (!isset($field_map) || $reset_cache) {
    if (!$reset_cache && ($cache = cache_get('text_or_entity:field_map')) && !empty($cache->data)) {
      $field_map = unserialize($cache->data);
    }
    else {
      // Rebuild static cache for $field_map.
      $field_map = array();
      $fields = field_info_field_map();
      foreach ($fields as $field_name => $field_info) {
        // Only process text_or_entity fields.
        if ($field_info['type'] == 'text_or_entity') {
          $field = field_info_field($field_name);
          $target_type = $field['settings']['entity_selection']['target_type'];
          $target_bundles = $field['settings']['entity_selection']['target_bundles'];
          $target_bundles = empty($target_bundles) ? array_keys(_text_or_entity_get_bundles_options($target_type)) : $target_bundles;
          foreach ($target_bundles as $target_bundle) {
            // Create new field_map entry.
            if (!isset($field_map[0])) {
              $field_map[0] = array();
            }
            array_push($field_map[0], $field_name);
            if (!isset($field_map[$target_type])) {
              $field_map[$target_type] = array();
            }
            if (!isset($field_map[$target_type][0])) {
              $field_map[$target_type][0] = array();
            }
            array_push($field_map[$target_type][0], $field_name);
            if (!isset($field_map[$target_type][$target_bundle])) {
              $field_map[$target_type][$target_bundle] = array();
            }
            array_push($field_map[$target_type][$target_bundle], $field_name);
          }
        }
      }
      cache_set('text_or_entity:field_map', serialize($field_map));
    }
  }
  if (!$entity_type) {
    return isset($field_map[0]) ? $field_map[0] : array();
  }
  if (!isset($field_map[$entity_type])) {
    return array();
  }
  if (!$entity_bundle) {
    return $field_map[$entity_type][0];
  }
  elseif (!isset($field_map[$entity_type][$entity_bundle])) {
    return array();
  }
  return $field_map[$entity_type][$entity_bundle];
}

/**
 * Implements hook_entity_insert().
 */
function text_or_entity_entity_insert($entity, $entity_type) {
  list($entity_id, , $entity_bundle) = entity_extract_ids($entity_type, $entity);
  $fields = _text_or_entity_field_map($entity_type, $entity_bundle);
  foreach ($fields as $field_name) {
    $table_name = 'field_data_' . $field_name;
    $target_id_column = $field_name . '_target_id';
    $value_column = $field_name . '_value';
    $entity_label = entity_label($entity_type, $entity);
    // Update target_id of fields matching inserted entity label.
    db_update($table_name)
      ->fields(array($target_id_column => $entity_id))
      ->condition($value_column, $entity_label, '=')
      ->execute();
    // Flush field cache of affected host entities.
    $source_ids = db_select($table_name, 't')
      ->fields('t', array('entity_id', $field_name . '_source_type'))
      ->condition($target_id_column, $entity_id, '=')
      ->execute()
      ->fetchAllKeyed();
    foreach ($source_ids as $source_id => $source_type) {
      cache_clear_all('field:' . $source_type . ':' . $source_id, 'cache_field');
    }
  }
}

/**
 * Implements hook_entity_update().
 */
function text_or_entity_entity_update($entity, $entity_type) {
  list($entity_id, , $entity_bundle) = entity_extract_ids($entity_type, $entity);
  $fields = _text_or_entity_field_map($entity_type, $entity_bundle);
  foreach ($fields as $field_name) {
    $table_name = 'field_data_' . $field_name;
    $target_id_column = $field_name . '_target_id';
    $value_column = $field_name . '_value';
    $entity_label = entity_label($entity_type, $entity);
    // Update target_id of fields matching updated entity label.
    db_update($table_name)
      ->fields(array($target_id_column => $entity_id))
      ->condition($value_column, $entity_label, '=')
      ->execute();
    // Update text value of fields referencing updated entity id.
    db_update($table_name)
      ->fields(array($value_column => $entity_label))
      ->condition($target_id_column, $entity_id, '=')
      ->execute();
    // Flush field cache of affected host entities.
    $source_ids = db_select($table_name, 't')
      ->fields('t', array('entity_id', $field_name . '_source_type'))
      ->condition($target_id_column, $entity_id, '=')
      ->execute()
      ->fetchAllKeyed();
    foreach ($source_ids as $source_id => $source_type) {
      cache_clear_all('field:' . $source_type . ':' . $source_id, 'cache_field');
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function text_or_entity_entity_delete($entity, $entity_type) {
  list($entity_id, , $entity_bundle) = entity_extract_ids($entity_type, $entity);
  $fields = _text_or_entity_field_map($entity_type, $entity_bundle);
  foreach ($fields as $field_name) {
    $table_name = 'field_data_' . $field_name;
    $target_id_column = $field_name . '_target_id';
    $value_column = $field_name . '_value';
    $entity_label = entity_label($entity_type, $entity);
    // Flush field cache of affected host entities.
    $source_ids = db_select($table_name, 't')
      ->fields('t', array('entity_id', $field_name . '_source_type'))
      ->condition($target_id_column, $entity_id, '=')
      ->execute()
      ->fetchAllKeyed();
    foreach ($source_ids as $source_id => $source_type) {
      cache_clear_all('field:' . $source_type . ':' . $source_id, 'cache_field');
    }
    // Update target_id of fields matching entity label.
    db_update($table_name)
      ->fields(array($target_id_column => NULL))
      ->condition($value_column, $entity_label, '=')
      ->execute();
  }
}

/**
 * Implements hook_views_api().
 */
function text_or_entity_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'text_or_entity'),
  );
}
