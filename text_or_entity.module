<?php

/**
 * @file
 * Defines the Text or Entity field type.
 */

/**
 * Implements hook_field_info().
 *
 * Field settings:
 *   - max_length: maximum length for varchar text value.
 *   - target_type: specific type of target entity.
 *   - target_bundles: specific bundle(s) of target entity.
 */
function text_or_entity_field_info() {
  return array(
    'text_or_entity' => array(
      'label' => t('Text or Entity'),
      'description' => t('This field stores varchar text and optional matching entity reference.'),
      'settings' => array(
        'max_length' => 255,
        'entity_selection' => array(
          'target_type' => 'node',
          'target_bundles' => array(),
        ),
      ),
      'instance_settings' => array(
        'text_processing' => FALSE,
      ),
      'default_widget' => 'text_or_entity_autocomplete',
      'default_formatter' => 'text_or_entity_link',

    ),
  );
}

/**
 * Implements hook_field_is_empty().
 */
function text_or_entity_field_is_empty($item, $field) {
  $empty_value = !isset($item['value']) || $item['value'] === '';
  $empty_target_id = !isset($item['target_id']) || $item['target_id'] === NULL;

  return $empty_value && $empty_target_id;
}

/**
 * Implements hook_field_validate().
 */
function text_or_entity_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  $target_type = $field['settings']['entity_selection']['target_type'];

  foreach ($items as $delta => $item) {
    // TODO: Really verify value / target_id combination.
    if (text_or_entity_field_is_empty($item, $field) && isset($item['target_id']) && $item['target_id'] !== NULL) {
      // Empty value with non-empty target_id.
      $errors[$field['field_name']][$langcode][$delta][] = array(
        'error' => 'text_or_entity_empty_label',
        'message' => t('Referenced entity (@type: @id) has empty text label.',
          array('@type' => $target_type, '@id' => $item['target_id'])),
      );
    }
  }
}

/**
 * Implements hook_field_settings_form().
 */
function text_or_entity_field_settings_form($field, $instance, $has_data) {
  $form = array(
    '#type' => 'container',
    '#prefix' => '<div id="text-or-entity-field-settings">',
    '#suffix' => '</div>',
    '#process' => array('_text_or_entity_field_settings_process'),
    '#element_validate' => array('_text_or_entity_field_settings_validate'),
    '#field' => $field,
    '#instance' => $instance,
    '#has_data' => $has_data,
  );

  return $form;
}

/**
 * Process callback to build the Text or Entity field settings form.
 */
function _text_or_entity_field_settings_process($form, $form_state) {
  $field = isset($form_state['text_or_entity']['field']) ? $form_state['text_or_entity']['field'] : $form['#field'];
  $has_data = $form['#has_data'];

  // Text value maximum length.
  $form['max_length'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum length'),
    '#default_value' => $field['settings']['max_length'],
    '#required' => TRUE,
    '#description' => t('The maximum length of the text value in characters.'),
    '#element_validate' => array('element_validate_integer_positive'),
    '#disabled' => $has_data,
  );

  // Dynamic selection of target entity type and bundle(s).
  $form['entity_selection'] = array(
    '#type' => 'fieldset',
    '#title' => t('Entity selection'),
  );
  $target_entity_type = $field['settings']['entity_selection']['target_type'];
  $form['entity_selection']['target_type'] = array(
    '#type' => 'select',
    '#title' => t('Target type'),
    '#options' => _text_or_entity_get_entity_type_options(),
    '#default_value' => $target_entity_type,
    '#description' => t('The entity type that can be referenced through this field.'),
    '#disabled' => $has_data,
    '#size' => 1,
    '#ajax' => array(
      'callback' => '_text_or_entity_field_settings_ajax_callback',
      'wrapper' => 'text-or-entity-field-settings',
    ),
  );
  $entity_info = entity_get_info($target_entity_type);
  if (!empty($entity_info['entity keys']['bundle'])) {
    // Bundles options for that entity type.
    $form['entity_selection']['target_bundles'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Target bundles'),
      '#options' => _text_or_entity_get_bundles_options($target_entity_type),
      '#default_value' => $field['settings']['entity_selection']['target_bundles'],
      '#description' => t('The bundles of the entity type that can be referenced. Optional, leave empty for all bundles.'),
      '#disabled' => $has_data,
    );
  }
  else {
    // Entity doesn't have bundles.
    $form['entity_selection']['target_bundles'] = array(
      '#type' => 'hidden',
      '#value' => array(),
    );
  }

  return $form;
}

/**
 * AJAX callback to rebuild the target_bundles settings.
 */
function _text_or_entity_field_settings_ajax_callback($form, $form_state) {
  return $form['field']['settings'];
}

/**
 * Validate field settings from the form state values.
 */
function _text_or_entity_field_settings_validate($form, &$form_state) {
  // Store the new field settings in the form state.
  $field = $form['#field'];
  if (isset($form_state['values']['field'])) {
    $field['settings'] = $form_state['values']['field']['settings'];
  }
  $form_state['text_or_entity']['field'] = $field;
}

/**
 * Helper function to get available entity types options.
 *
 * @return array
 *   The available entity types options.
 */
function _text_or_entity_get_entity_type_options() {
  $entity_type_options = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    $entity_type_options[$entity_type] = $entity_info['label'];
  }

  return $entity_type_options;
}

/**
 * Helper function to get bundles options from entity type.
 *
 * @param string $entity_type
 *   Entity type for which to retrieve bundles options.
 *
 * @return array
 *   The bundles options for that entity type.
 */
function _text_or_entity_get_bundles_options($entity_type) {
  $bundles_options = array();

  if (empty($entity_type)) {
    return array();
  }
  if ($bundles_info = field_info_bundles($entity_type)) {
    foreach ($bundles_info as $bundle_name => $bundle) {
      $bundles_options[$bundle_name] = $bundle['label'];
    }
  }

  return $bundles_options;
}

/**
 * Implements hook_field_instance_settings_form().
 */
function text_or_entity_field_instance_settings_form($field, $instance) {
  $form = array();

  $form['text_processing'] = array(
    '#type' => 'hidden',
    '#value' => FALSE,
  );

  return $form;
}

/**
 * Implements hook_field_widget_info().
 */
function text_or_entity_field_widget_info() {
  return array(
    'text_or_entity_autocomplete' => array(
      'label' => t('Autocomplete'),
      'description' => t('An autocomplete text field.'),
      'field types' => array('text_or_entity'),
      'settings' => array(
        'size' => 60,
        // TODO: Add autocomplete suggestions limit to widget settings.
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function text_or_entity_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];
  $form = array();

  // Only process text_or_entity widget
  if ($widget['type'] == 'text_or_entity_autocomplete') {
    $form['size'] = array(
      '#type' => 'textfield',
      '#title' => t('Size of textfield'),
      '#default_value' => $settings['size'],
      '#required' => TRUE,
      '#element_validate' => array('element_validate_integer_positive'),
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function text_or_entity_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  if ($instance['widget']['type'] == 'text_or_entity_autocomplete') {
    // Reuse text_textfield widget form.
    $instance['widget']['type'] = 'text_textfield';
    $element = text_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
    // Add autocomplete path and validation to value field.
    $element['value'] += array(
      '#autocomplete_path' => 'text_or_entity/autocomplete/' .
        $element['#field_name'] . '/' . $element['#entity_type'] . '/' . $element['#bundle'],
      '#element_validate' => array('_text_or_entity_autocomplete_validate'),
    );
    $element['target_id'] = array(
      '#type' => 'hidden',
      '#default_value' => isset($items[$delta]['target_id']) ? $items[$delta]['target_id'] : NULL,
    );
  }

  return $element;
}

/**
 * Implements hook_menu().
 *
 * We only need this for the widget autocomplete feature.
 */
function text_or_entity_menu() {
  $items = array();

  $items['text_or_entity/autocomplete/%/%/%'] = array(
    'title' => 'Text or Entity Autocomplete',
    'page callback' => 'text_or_entity_autocomplete_callback',
    'page arguments' => array(2, 3, 4),
    'access callback' => 'text_or_entity_autocomplete_access_callback',
    'access arguments' => array(2, 3, 4),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Menu Access callback for the Text or Entity autocomplete widget.
 *
 * @param $field_name
 *   The name of the text_or_entity field.
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name.
 *
 * @return
 *   True if user can access this menu item.
 */
function text_or_entity_autocomplete_access_callback($field_name, $entity_type, $bundle_name) {
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  if (!$field || !$instance || $field['type'] != 'text_or_entity' || !field_access('edit', $field, $entity_type)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Menu callback: autocomplete previous text values or the label of an entity.
 *
 * @param $field_name
 *   The name of the entity-reference field.
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name.
 * @param $string
 *   The label of the entity to query by.
 */
function text_or_entity_autocomplete_callback($field_name, $entity_type, $bundle_name, $string = '') {
  // If the request has a '/' in the search text, then the menu system will
  // have split it into multiple arguments and $string will only be a partial.
  // We want to make sure we recover the intended $string.
  $args = func_get_args();
  // Shift off the $field_name, $entity_type and $bundle_name args.
  array_shift($args);
  array_shift($args);
  array_shift($args);
  $string = implode('/', $args);

  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  text_or_entity_autocomplete_matches_json_output($field, $instance, $entity_type, $string);
}

/**
 * Output JSON based on given field, instance and string.
 *
 * @param $field
 *   The field array defintion.
 * @param $instance
 *   The instance array defintion.
 * @param $entity_type
 *   The entity type.
 * @param $string
 *   The label of the entity to query by.
 */
function text_or_entity_autocomplete_matches_json_output($field, $instance, $entity_type, $string = '') {
  $matches = array();

  // TODO: Build autocomplete suggestions from previous text values and matching entities.

  // Merge and sanitize output.
  foreach ($matches as $key => &$value) {
    // Add a class wrapper for a few required CSS overrides.
    // We use $key since $value might hold the link to an entity.
    $value = '<div class="reference-autocomplete">' . check_plain($key) . '</div>';
  }
  asort($matches, SORT_LOCALE_STRING);

  drupal_json_output($matches);
}

/**
 * Validation callback for widget form.
 */
function _text_or_entity_autocomplete_validate($element, &$form_state, $form) {
  $target_id = NULL;

  // TODO: Determine target_id from autocompleted value.

  // Change submitted form value for target_id.
  $parents = $element['#array_parents'];
  array_pop($parents);
  $parent_element = drupal_array_get_nested_value($form, $parents);
  form_set_value($parent_element['target_id'], $target_id, $form_state);
}

/**
 * Implements hook_field_formatter_info().
 */
function text_or_entity_field_formatter_info() {
  return array(
    'text_or_entity_link' => array(
      'label' => t('Text or Entity link'),
      'field types' => array('text_or_entity'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function text_or_entity_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $elements = array();

  if ($display['type'] == 'text_or_entity_link') {
    foreach ($items as $delta => $item) {
      if (isset($item['target_id']) && $item['target_id'] !== NULL) {
        // Display as a link to the target entity.
        $path = $field['settings']['entity_selection']['target_type'] . '/' . $item['target_id'];
        $elements[$delta] = array('#markup' => l($item['value'], $path));
      }
      else {
        // Display as text value.
        $elements[$delta] = array('#markup' => $item['value']);
      }
    }
  }
  return $elements;
}

/**
 * Implements hook_views_api().
 */
function text_or_entity_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'text_or_entity') . '/views',
  );
}
