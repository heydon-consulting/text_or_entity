<?php

/**
 * @file
 * Defines the Text or Entity field type.
 */

/**
 * Implements hook_field_info().
 *
 * Field settings:
 *   - max_length: maximum length for varchar text value.
 *   - target_type: specific type of target entity.
 *   - target_bundles: specific bundle(s) of target entity.
 */
function text_or_entity_field_info() {
  return array(
    'text_or_entity' => array(
      'label' => t('Text or Entity'),
      'description' => t('This field stores varchar text and optional matching entity reference.'),
      'settings' => array(
        'max_length' => 255,
        'entity_selection' => array(
          'target_type' => 'node',
          'target_bundles' => array(),
        ),
      ),
      'instance_settings' => array(
        'text_processing' => FALSE,
      ),
      'default_widget' => 'text_or_entity_autocomplete',
      'default_formatter' => 'text_or_entity_link',

    ),
  );
}

/**
 * Implements hook_field_is_empty().
 */
function text_or_entity_field_is_empty($item, $field) {
  $empty_value = !isset($item['value']) || $item['value'] === '';
  $empty_target_id = !isset($item['target_id']) || $item['target_id'] === NULL;

  return $empty_value && $empty_target_id;
}

/**
 * Implements hook_field_validate().
 */
function text_or_entity_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  $target_type = $field['settings']['entity_selection']['target_type'];

  foreach ($items as $delta => $item) {
    // TODO: Really verify value / target_id combination.
    if (text_or_entity_field_is_empty($item, $field) && isset($item['target_id']) && $item['target_id'] !== NULL) {
      // Empty value with non-empty target_id.
      $errors[$field['field_name']][$langcode][$delta][] = array(
        'error' => 'text_or_entity_empty_label',
        'message' => t('Referenced entity (@type: @id) has empty text label.',
          array('@type' => $target_type, '@id' => $item['target_id'])),
      );
    }
  }
}

/**
 * Implements hook_field_settings_form().
 */
function text_or_entity_field_settings_form($field, $instance, $has_data) {
  $form = array(
    '#type' => 'container',
    '#prefix' => '<div id="text-or-entity-field-settings">',
    '#suffix' => '</div>',
    '#process' => array('_text_or_entity_field_settings_process'),
    '#element_validate' => array('_text_or_entity_field_settings_validate'),
    '#field' => $field,
    '#instance' => $instance,
    '#has_data' => $has_data,
  );

  return $form;
}

/**
 * Process callback to build the Text or Entity field settings form.
 */
function _text_or_entity_field_settings_process($form, $form_state) {
  $field = isset($form_state['text_or_entity']['field']) ? $form_state['text_or_entity']['field'] : $form['#field'];
  $has_data = $form['#has_data'];

  // Text value maximum length.
  $form['max_length'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum length'),
    '#default_value' => $field['settings']['max_length'],
    '#required' => TRUE,
    '#description' => t('The maximum length of the text value in characters.'),
    '#element_validate' => array('element_validate_integer_positive'),
    '#disabled' => $has_data,
  );

  // Dynamic selection of target entity type and bundle(s).
  $form['entity_selection'] = array(
    '#type' => 'fieldset',
    '#title' => t('Entity selection'),
  );
  $target_entity_type = $field['settings']['entity_selection']['target_type'];
  $form['entity_selection']['target_type'] = array(
    '#type' => 'select',
    '#title' => t('Target type'),
    '#options' => _text_or_entity_get_entity_type_options(),
    '#default_value' => $target_entity_type,
    '#description' => t('The entity type that can be referenced through this field.'),
    '#disabled' => $has_data,
    '#size' => 1,
    '#ajax' => array(
      'callback' => '_text_or_entity_field_settings_ajax_callback',
      'wrapper' => 'text-or-entity-field-settings',
    ),
  );
  $entity_info = entity_get_info($target_entity_type);
  if (!empty($entity_info['entity keys']['bundle'])) {
    // Bundles options for that entity type.
    $form['entity_selection']['target_bundles'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Target bundles'),
      '#options' => _text_or_entity_get_bundles_options($target_entity_type),
      '#default_value' => $field['settings']['entity_selection']['target_bundles'],
      '#description' => t('The bundles of the entity type that can be referenced. Optional, leave empty for all bundles.'),
      '#disabled' => $has_data,
    );
  }
  else {
    // Entity doesn't have bundles.
    $form['entity_selection']['target_bundles'] = array(
      '#type' => 'hidden',
      '#value' => array(),
    );
  }

  return $form;
}

/**
 * AJAX callback to rebuild the target_bundles settings.
 */
function _text_or_entity_field_settings_ajax_callback($form, $form_state) {
  return $form['field']['settings'];
}

/**
 * Validate field settings from the form state values.
 */
function _text_or_entity_field_settings_validate($form, &$form_state) {
  // Store the new field settings in the form state.
  $field = $form['#field'];
  if (isset($form_state['values']['field'])) {
    $field['settings'] = $form_state['values']['field']['settings'];
  }
  $form_state['text_or_entity']['field'] = $field;
}

/**
 * Helper function to get available entity types options.
 *
 * @return array
 *   The available entity types options.
 */
function _text_or_entity_get_entity_type_options() {
  $entity_type_options = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    $entity_type_options[$entity_type] = $entity_info['label'];
  }

  return $entity_type_options;
}

/**
 * Helper function to get bundles options from entity type.
 *
 * @param string $entity_type
 *   Entity type for which to retrieve bundles options.
 *
 * @return array
 *   The bundles options for that entity type.
 */
function _text_or_entity_get_bundles_options($entity_type) {
  $bundles_options = array();

  if (empty($entity_type)) {
    return array();
  }
  if ($bundles_info = field_info_bundles($entity_type)) {
    foreach ($bundles_info as $bundle_name => $bundle) {
      $bundles_options[$bundle_name] = $bundle['label'];
    }
  }

  return $bundles_options;
}

/**
 * Implements hook_field_instance_settings_form().
 */
function text_or_entity_field_instance_settings_form($field, $instance) {
  $form = array();

  $form['text_processing'] = array(
    '#type' => 'hidden',
    '#value' => FALSE,
  );

  return $form;
}

/**
 * Implements hook_field_widget_info().
 */
function text_or_entity_field_widget_info() {
  return array(
    'text_or_entity_autocomplete' => array(
      'label' => t('Autocomplete'),
      'description' => t('An autocomplete text field.'),
      'field types' => array('text_or_entity'),
      'settings' => array(
        'size' => 60,
        'match_operator' => 'starts_with',
        'limit' => 10,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function text_or_entity_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];
  $form = array();

  // Only process text_or_entity widget
  if ($widget['type'] == 'text_or_entity_autocomplete') {
    // Textfield size.
    $form['size'] = array(
      '#type' => 'textfield',
      '#title' => t('Size of textfield'),
      '#default_value' => $settings['size'],
      '#required' => TRUE,
      '#element_validate' => array('element_validate_integer_positive'),
    );
    // Autocomplete match operator (starts_with or contains).
    $form['match_operator'] = array(
      '#type' => 'select',
      '#title' => t('Autocomplete match operator'),
      '#default_value' => $settings['match_operator'],
      '#options' => array(
        'starts_with' => t('Starts with'),
        'contains' => t('Contains'),
      ),
      '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of records.'),
    );
    // Autocomplete suggestions limit (<100).
    $form['limit'] = array(
      '#type' => 'textfield',
      '#title' => t('Autocomplete limit'),
      '#description' => t('Limit the size of the autocomplete suggestions list (<100).'),
      '#default_value' => $settings['limit'],
      '#size' => 3,
      '#maxlength' => 2,
      '#element_validate' => array('element_validate_integer_positive'),
      '#required' => TRUE,
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function text_or_entity_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  if ($instance['widget']['type'] == 'text_or_entity_autocomplete') {
    // Reuse text_textfield widget for value element.
    $instance['widget']['type'] = 'text_textfield';
    $element = text_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
    // Add autocomplete path and validation to value field.
    $element['value'] += array(
      '#autocomplete_path' => 'text_or_entity/autocomplete/' .
        $element['#field_name'] . '/' . $element['#entity_type'] . '/' . $element['#bundle'],
      '#element_validate' => array('_text_or_entity_autocomplete_validate'),
      '#field' => $field,
      '#instance' => $instance,
      '#langcode' => $langcode,
      '#delta' => $delta,
    );
    // Store target_id in a hidden element.
    $target_id = isset($items[$delta]) && !empty($items[$delta]['target_id']) ? $items[$delta]['target_id'] : NULL;
    $element['target_id'] = array(
      '#type' => 'hidden',
      '#default_value' => $target_id,
    );
  }

  return $element;
}

/**
 * Implements hook_menu().
 *
 * We only need this for text_or_entity_autocomplete widget.
 */
function text_or_entity_menu() {
  $items = array();

  $items['text_or_entity/autocomplete/%/%/%'] = array(
    'title' => 'Text or Entity Autocomplete',
    'page callback' => 'text_or_entity_autocomplete_callback',
    'page arguments' => array(2, 3, 4),
    'access callback' => 'text_or_entity_autocomplete_access_callback',
    'access arguments' => array(2, 3, 4),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Menu Access callback for the Text or Entity autocomplete widget.
 *
 * @param $field_name
 *   The name of the text_or_entity field.
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name.
 *
 * @return
 *   True if user can access this menu item.
 */
function text_or_entity_autocomplete_access_callback($field_name, $entity_type, $bundle_name) {
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  if (!$field || !$instance || $field['type'] != 'text_or_entity' || !field_access('edit', $field, $entity_type)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Menu callback: autocomplete previous text values or the label of an entity.
 *
 * @param $field_name
 *   The name of the entity-reference field.
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name.
 * @param $string
 *   The label of the entity to query by.
 */
function text_or_entity_autocomplete_callback($field_name, $entity_type, $bundle_name, $string = '') {
  // If the request has a '/' in the search text, then the menu system will
  // have split it into multiple arguments and $string will only be a partial.
  // We want to make sure we recover the intended $string.
  $args = func_get_args();
  // Shift off the $field_name, $entity_type and $bundle_name args.
  array_shift($args);
  array_shift($args);
  array_shift($args);
  $string = implode('/', $args);

  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  text_or_entity_autocomplete_matches_json_output($field, $instance, $entity_type, $string);
}

/**
 * Output JSON based on given field, instance and string.
 *
 * @param $field
 *   The field array defintion.
 * @param $instance
 *   The instance array defintion.
 * @param $entity_type
 *   The entity type.
 * @param $string
 *   The label of the entity to query by.
 */
function text_or_entity_autocomplete_matches_json_output($field, $instance, $entity_type, $string = '') {
  // Get autocomplete suggestions from previous text values.
  $matches = text_or_entity_query_field_data($field, $instance, $string, FALSE);

  // Merge autocomplete suggestions from matching entities.
  $matches = array_merge($matches, text_or_entity_query_entity_label($field, $instance, $string, FALSE));

  // Merge and sanitize output.
  $suggestions = array();
  foreach ($matches as $key => $match) {
    // Add a class wrapper for a few required CSS overrides.
    $suggestions[$key] = '<div class="reference-autocomplete">' . check_plain($match['value']) . '</div>';
  }
  asort($suggestions, SORT_LOCALE_STRING);

  drupal_json_output($suggestions);
}

/**
 * Validation callback for widget form.
 */
function _text_or_entity_autocomplete_validate($element, &$form_state, $form) {
  // Determine target_id from text value.
  $value = $form_state['values'][$element['#field_name']][$element['#langcode']][$element['#delta']]['value'];
  $matches = text_or_entity_query_entity_label($element['#field'], $element['#instance'], $value, TRUE);
  $target_id = count($matches) ? $matches[$value]['target_id'] : NULL;

  // Set target_id in the submitted form values.
  $parents = $element['#array_parents'];
  array_pop($parents);
  $parent_element = drupal_array_get_nested_value($form, $parents);
  form_set_value($parent_element['target_id'], $target_id, $form_state);
}

/**
 * Implements hook_field_formatter_info().
 */
function text_or_entity_field_formatter_info() {
  return array(
    'text_or_entity_link' => array(
      'label' => t('Text or Entity link'),
      'field types' => array('text_or_entity'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function text_or_entity_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $elements = array();

  if ($display['type'] == 'text_or_entity_link') {
    foreach ($items as $delta => $item) {
      if (isset($item['target_id']) && $item['target_id'] !== NULL) {
        // Display as a link to the target entity.
        $path = $field['settings']['entity_selection']['target_type'] . '/' . $item['target_id'];
        $elements[$delta] = array('#markup' => l($item['value'], $path));
      }
      else {
        // Display as text value.
        $elements[$delta] = array('#markup' => $item['value']);
      }
    }
  }

  return $elements;
}

/**
 * Helper function to query existing field data.
 *
 * @param $field
 *   Text or Entity field for which this query should be made.
 * @param $instance
 *   Text or Entity field instance for which this query should be made.
 * @param $string
 *   String or partial string to search for.
 * @param $exact
 *   Use exact match instead of starts_with / contains.
 *
 * @return array
 *   Matching text values found in the specified field's data, for example:
 *   array('Text value' => array(
 *     'value' => 'Text value',
 *     'target_id' => NULL,
 *   ))
 */
function text_or_entity_query_field_data($field, $instance, $string, $exact) {
  $widget = $instance['widget'];
  $match_operator = $widget['settings']['match_operator'];
  $limit = $widget['settings']['limit'];
  $matches = array();

  // Do not act upon empty search string or unrelated fields.
  if ($string != '' && $field['type'] == 'text_or_entity') {
    // Build query to search for existing field data
    $field_name = $field['field_name'];
    $query = db_select('field_data_' . $field_name)
      ->fields('field_data_' . $field_name, array($field_name . '_value'));
    if ($exact) {
      // Query for exact value of $string
      $query->condition($field_name . '_value', $string, '=');
    }
    else {
      // Query for value containing or starting with $string
      $needle = db_like($string) . '%';
      if ($match_operator == 'contains') {
        $needle = '%' . $needle;
      }
      $query->condition($field_name . '_value', $needle, 'LIKE');
    }
    $query->groupBy($field_name . '_value')
      ->orderBy($field_name . '_value')
      ->range(0, $limit);
    $result = $query->execute();
    foreach ($result as $value) {
      $value = $value->{$field_name . '_value'};
      $matches[$value] = array(
        'value' => $value,
        'target_id' => NULL,
      );
    }
  }

  return $matches;
}

/**
 * Helper function to query entities by their label value.
 *
 * @param $field
 *   Text or Entity field for which this query should be made.
 * @param $instance
 *   Text or Entity field instance for which this query should be made.
 * @param $string
 *   String or partial string to search for.
 * @param $exact
 *   Use exact match instead of starts_with / contains.
 *
 * @return array
 *   Matching text values found in the specified field's data, for example:
 *   array('Entity label' => array(
 *     'value' => 'Entity label',
 *     'target_id' => 10,
 *   ))
 */
function text_or_entity_query_entity_label($field, $instance, $string, $exact) {
  $widget = $instance['widget'];
  $match_operator = $widget['settings']['match_operator'];
  $limit = $widget['settings']['limit'];
  $matches = array();

  // TODO: Query entities by label.

  return $matches;
}

/**
 * Implements hook_views_api().
 */
function text_or_entity_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'text_or_entity') . '/views',
  );
}
